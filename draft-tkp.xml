<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>

<rfc ipr="trust200902" docName="draft-tkp.txt" category="std">

    <front>
        <title>TLS Key Pinning</title>
        <author initials='M.M.' surname="Marlinspike" fullname='Moxie Marlinspike'>	
            <organization/>
        </author>
        <author initials='T.P.' surname="Perrin" fullname='Trevor Perrin' 
				role="editor">
            <organization/>
			<address><email>tkp@trevp.net</email></address>
        </author>
        <date/>
		<area>Security</area>
		<workgroup>TLS Working Group</workgroup>
        <abstract>
			<t>

This document defines TKP, which allows a TLS server to publish a list of
public keys which clients can "pin" to the server's hostname. TLS connections
to a pinned hostname must contain one of the pinned public keys, either in the
server's X.509 certificate chain, or as a tack-signing key.

			</t>
		</abstract>
    </front>

    <middle>
		<section anchor="intro" title="Introduction">
			<t>

Traditionally, a TLS client verifies a TLS server's public key using a
certificate chain issued by some public CA. "Pinning" is a way for clients to
obtain increased certainty in server public keys. Clients that employ pinning
check for some constant "pinned" element of the TLS connection when
contacting a particular TLS host.

 </t> <t>

TKP lets a server publish a "pin description" listing the public keys it would
like to be pinned to. Once a client has seen the same pin description multiple
times, the client will "activate" a "pin" between the hostname and description
for a period equal to the length of time the pair has been observed for. This
"pin activation" algorithm limits the impact of bad pins resulting from
transient network attacks or operator error.

			</t>
			<t>

TKP pins are easily shared between clients. For example, a TKP client may
scan the internet to discover TKP pins, then publish these pins through some
3rd-party trust infrastructure for other clients to rely upon.

</t>
 </section> 


<section title="Requirements notation"> <t>The key words "MUST",
"MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in <xref target="RFC2119"/>.</t> 
</section>

<section title="Overview">

<section title="TKP life cycle">

<t>A server operator using TKP may perform several processes:

	<list style="hanging">
	<t hangText="Creating a pin description:">	

The server operator first chooses the pin description to use for a set of
hostnames.

	</t>
	<t hangText="Deploying pin descriptions:">	

For each hostname, pin descriptions are deployed to TLS servers in a two-stage
process. First, each TLS server associated with the hostname publishes the pin
description along with a matching X.509 chain or tack. Once this is completed,
the pin descriptions are activated by setting the "activation flag" on each
server.

	</t>
	
	<t hangText="Deactivating pin descriptions:">

If a server operator wishes to stop deploying TKP, all pin descriptions for a
hostname can be deactivated via the activation flag, allowing the server to
remove the pin descriptions within 30 days (at the most).

	</t>
	<t hangText="Overlapping pin descriptions:">

If a server operator wishes to change the pin description a hostname is pinned
to, the server can publish a new description alongside the old one. This lets
clients activate pins for the new description prior to the older pins being deactivated.

	</t>
	
	</list>
	<vspace blankLines="100" />	
</t>
	

</section>

<section title="Pin life cycle">
	
	<t>

A TKP pin associates a hostname and a pin description (or a hash of a pin
description). Pins are grouped into "pin stores". A client may populate its
pin stores by either performing "pin activation" directly, or by querying some
other party. For example, a client application may have a store for pin
activation as well as a store whose contents are periodically fetched from a
server. </t>

<t>

Whenever a client performing "pin activation" sees a hostname and pin
description pair not represented in the "pin activation" pin store, an
inactive pin is created. Every subsequent time the client sees the same pair,
the pin is "activated" for a period equal to the timespan between the first
time the pin was seen and the most recent time, up to a maximum period of 30
days.

</t>

<t>

A pin store may contain up to two pins per hostname. This allows for
overlapping pins when a server is securely transitioning from one pin to
another. If both pins are simultaneously active, then the server must satisfy
both of them by presenting a pair of descriptions.

</t>

</section>
</section>

<section title="TKP Extension">
	<section title="Definition of PinExtension">
	<t>

A new TLS ExtensionType ("tkp") is defined and MAY be included by a TLS
client in the ClientHello message defined in <xref target="RFC5246"/>.

</t>
<figure><artwork>
enum {tkp(TBD), (65535)} ExtensionType;
</artwork></figure>	
<t>

The "extension_data" field of this ClientHello extension SHALL be empty. A TLS
server which is not resuming a TLS session MAY respond with an extension of
type "tkp" in the ServerHello. The "extension_data" field of this
ServerHello extension SHALL contain a "PinExtension", as defined below using
the TLS presentation language from <xref target="RFC5246"/>.

	</t>
<figure><artwork>
enum { x509_key(0), tack_signing_key(1) } PinElementType;

struct {
  PinElementType element_type;
  uint8          element_hash[32];        /* sha256 */
} PinElement;                             /* 33 bytes */

struct{
  uint32         flags;
  PinElement     elements&lt;0...528&gt;;       /* 1...16 elements */
} PinDescription;                         /* 34...532 bytes */

struct {
  uint8          activation_flags;
  PinDescription descriptions&lt;34...1064&gt;; /* 1 or 2 descriptions */
} PinExtension;                           /* 35...1065 bytes */
</artwork>
</figure>
<t>
<vspace blankLines="100" />	

</t>
</section>
<section title="Explanation of PinExtension fields">

<section title="PinElement fields">
<t>
<list style="hanging">

	<t hangText="element_type:">

This field specifies whether the PinElement contains a hash of an X.509
certificate's SubjectPublicKeyInfo, or a hash of a 64-byte tack-signing key.

	</t>	
<t hangText="element_hash:"> 

This field is a SHA256 hash of either an X.509 SubjectPublicKeyInfo or a tack
signing key, as determined by the preceding "element_type".

</t>

</list>
</t>
</section>

<section title="PinDescription fields">
<t>
<list style="hanging">

<t hangText="flags:">

This field provides flags associated with the pin description. These flags may
specify desired error-handling behaviors or other aspects of client handling
(TBD). 

</t>

<t hangText="elements:">

This field contains 1...16 PinElements belonging to this PinDescription.


</t> </list> </t>

</section>

<section title="PinExtension fields">
<t>
<list style="hanging">

<t hangText="activation_flags:">

This field contains "activation flags" for the extension's PinDescriptions. If
the low order bit is set, the first description is considered active. If the
next lowest bit is set, the second description is considered active. An active
description MAY be used by the pin activation algorithm in <xref
target="creating"/> to create, activate, and extend the activation of TKP
pins. </t> 

<t hangText="descriptions:">

This field contains 1 or 2 PinDescriptions.

</t> </list> </t>

</section>



</section> 
</section>

<section title="Client processing" anchor="clientproc">
<section title="TKP pins">

<t>

A client SHALL have a local store of pins, and MAY have multiple stores. Each
pin store consists of a map associating fully qualified DNS hostnames with
either one or two sets of the following values:

<list style="hanging">
<t hangText="Initial time:">

A timestamp noting when this pin was created.

</t> 
<t hangText="End time:">

A timestamp determining the pin's "active period". If set to zero or a
time in the past, the pin is "inactive". If set to a future time, the pin is
"active" until that time.

</t> 

<t hangText="PinDescription (or hash):">

A PinDescription or a cryptographically-secure, second preimage-resistant hash of a PinDescription.

</t> 

</list>
</t>
<t>

A hostname along with the above values comprises a "TKP pin". Thus, each store
can hold up to two pins for a hostname (however, those two pins MUST reference
different PinDescriptions). A pin "matches" a PinDescription if it contains
the PinDescription or its hash. A pin is "relevant" if its hostname equals the
TLS server's hostname.

</t>

</section>

<section title="High-level client processing">

<t>

A TKP client SHALL send the "tkp" extension defined previously, and SHALL
send the "server_name" extension from <xref target="RFC6066"/>. If not
resuming a session, the server MAY respond with a PinExtension. Regardless of
whether a PinExtension is returned, the client SHALL perform the following
steps prior to using the connection:

<list style="numbers">
 <t>Check whether the TLS handshake is "well-formed".</t>
 <t>For each pin store, do:
<list style="letters">
    <t>Determine the store's status.</t>
    <t>Perform pin activation (optional).</t>
</list>

<vspace blankLines="100" />	

</t>
</list>

These steps SHALL be performed in order. If there is any error, the client
SHALL send a fatal error alert and close the connection, skipping the
remaining steps (see <xref target="details"/> for details).

</t>

<t>Based on step 2A, each store will report one of three statuses for the
connection: "accepted", "rejected", or "unpinned". A rejected connection might
indicate a network attack. If the connection is rejected the client MAY
send a fatal "access_denied" error alert and close the connection. </t> 

<t> A client MAY perform additional verification steps before using an
accepted or unpinned connection. See <xref target="certver"/> for an
example.</t>

</section> <section title="Client processing details" anchor="details">

<section title="Check whether the TLS handshake is well-formed"
anchor="wellformed">

<t>

A TLS handshake is "well-formed" if the following are true. Unless otherwise
specified, if any of the following are false a "bad_certificate" fatal error
alert SHALL be sent.

<list style="numbers">

<t>The handshake protocol negotiates a cryptographically secure ciphersuite
and finishes succesfully.</t>

<t>If a PinExtension is present then all length fields are correct,
and "activation_flags" is &lt;= 3.</t>

 <t>If there are two PinDescriptions, they are not identical.</t>

 <t>For each PinDescription, there is at least one PinElement that either (a)
is of type "x509_key" and refers to a SubjectPublicKeyInfo from the server's
certificate chain, or (b) is of type "tack_signing_key" and refers to a tack
signing key from a server tack.</t>

</list> </t>

</section>

<section title="Determine the store's status"> <t>

If there is a relevant active pin without a matching description, then the
connection is "rejected". If the connection is not rejected and there is a
relevant active pin with a matching description, then the connection is
"accepted". Otherwise, the connection is "unpinned".
<vspace blankLines="100" />	

</t>

</section>

<section title="Pin activation (optional)" anchor="creating">

<t>

The TLS connection MAY be used to create, delete, and activate pins. This "pin
activation algorithm" is optional; a client MAY rely on an external source of
pins. If the connection was "rejected" by the previous processing step, then
pin activation is skipped.

</t>
<t>

The first step in pin activation is to evaluate each relevant pin (there may
be one or two): <list style="numbers">

<t>If a pin has no matching description, its handling will depend on whether
the pin is active. If active, the connection will have been rejected, skipping
pin activation. If inactive, the pin SHALL be deleted, since it is
contradicted by the connection.</t>

<t>If a pin has a matching description, its handling will depend on whether
the description is active. If inactive, the pin is left unchanged. If active,
the pin SHALL have its "end time" set based on the current, initial, and end
times:

<figure><artwork> 
    end = current + MIN(30 days, current - initial)
</artwork></figure> </t> </list> </t>

<t> In sum: (1) deletes unmatched inactive pins; and (2) activates matched
pins with active descriptions. </t>

<t>The remaining step in pin activation is to add new inactive pins for any
unmatched active descriptions. Each new pin uses the server's hostname, the
description (or its hash), an "initial time" set to the current time, and an
"end time" of zero.

</t> 

<t> (Note that there are always sufficient empty "slots" in the pin store for
adding new pins without exceeding two pins per hostname. This is because the
number of matching pins equals the number of matching descriptions, so the
number of empty pin slots equals the number of unmatched descriptions.)

</t> 

<t>The following tables summarize this behavior from the perspective of a pin.
You can follow the lifecycle of a single pin from "New inactive pin" to
"Delete pin".
<vspace blankLines="100" />	

</t>
<t>Relevant pin is active:</t>

      <texttable>
           <ttcol align='left'>Pin matches a description</ttcol>
           <ttcol align='left'>Description is active</ttcol>
           <ttcol align='left'>Result</ttcol>

           <c>Yes</c>
           <c>Yes</c>
           <c>Extend activation period</c>

           <c>Yes</c>
           <c>No</c>
           <c>-</c>

           <c>No</c>
           <c>-</c>
           <c>(Connection rejected)</c>

       </texttable>

<t>Relevant pin is inactive:</t>

      <texttable>
           <ttcol align='left'>Pin matches a description</ttcol>
           <ttcol align='left'>Description is active</ttcol>
           <ttcol align='left'>Result</ttcol>

           <c>Yes</c>
           <c>Yes</c>
           <c>Activate pin</c>

           <c>Yes</c>
           <c>No</c>
           <c>-</c>

           <c>No</c>
           <c>-</c>
           <c>Delete pin</c>

       </texttable>

<t>Description doesn't match any relevant pin:</t>

      <texttable>
           <ttcol align='left'>Unmatched description is active</ttcol>
           <ttcol align='left'>Result</ttcol>

           <c>Yes</c>
           <c>New inactive pin</c>

           <c>No</c>
           <c>-</c>

       </texttable>


</section>
</section>	
</section>

<section title="Application protocols and TKP">
<section title="Pin scope">

<t> TKP pins are specific to a particular application protocol. In other
words, a pin for HTTPS at "example.com" implies nothing about POP3 or SMTP at
"example.com". </t>

</section>

<section title="TLS negotiation">

<t>Some application protocols negotiate TLS as an optional feature (e.g. SMTP
using STARTTLS <xref target="RFC3207"/>). If such a server fails to negotiate
TLS and there are relevant active pins, then the connection is rejected by the
pin. If the server fails to negotiate TLS, then any relevant, inactive pins
SHALL be deleted. Note that these steps are taken despite the absence of a TLS
connection.</t>

</section>

<section title="Certificate verification" anchor="certver">

 <t>

A TKP client MAY choose to perform some form of certificate verification in
addition to TKP processing. When combining certificate verification and TKP
processing, the TKP processing described in <xref target="clientproc"/> SHALL
be followed, with the exception that TKP processing MAY be terminated early
(or skipped) if some fatal certificate error is discovered.

</t>
<t>

If TKP processing and certificate verification both complete without a fatal
error, the client SHALL apply some policy to decide whether to accept the
connection. The policy is up to the client. An example policy would be to
accept the connection only if it passes certificate verification and is not
rejected by a pin.

</t>

</section>
</section>

<section title="Advice"> 
<section title="For server operators" anchor="servadvice">
<t>
<list style="hanging">

<t hangText="Aliases:">

A TLS server may be referenced by multiple hostnames. Clients may pin any of
these hostnames. Server operators should be careful when using DNS aliases
that hostnames are not pinned inadvertently.

</t>

<t hangText="Pin activation:">

Pin descriptions should only be activated once all TLS servers sharing the
same hostname have the description. Otherwise, a client may activate a
description by contacting one server, then contact a different server at the
same hostname that does not yet have the description. </t>

<t hangText="Pin deactivation:">If all servers at a hostname deactivate their
pin descriptions (by clearing the activation flags), all existing pins for the
hostname will eventually become inactive. The descriptions can be removed
after a time interval equal to the maximum active period of any affected pins
(30 days at most).

</t>

<t hangText="Pin overlap:">When publishing overlapping descriptions, the old
and new descriptions SHOULD be active simultaneously for at least 60 days.
This ensures that any pin activation client who is contacting the server at
intervals of 30 days or less will not have its activation periods interrupted.
Example process: activate new descriptions; wait 60 days; deactivate old
descriptions; wait 30 days; remove old descriptions. </t>

</list>
</t>
</section> 
<section title="For client implementers">
<t>
<list style="hanging">
<t hangText="Sharing pin information:">

It is possible for a client to maintain a pin store based entirely on its own
TLS connections. However, such a client runs the risk of creating incorrect
pins or failing to keep its pins active. Clients are advised to make use of
3rd-party trust infrastructure so that pin data can be aggregated and shared.
This will require additional protocols outside the scope of this document.

</t>

</list>
</t>
</section> 
</section>

        <section title="Security considerations" anchor="security">
<section title="For server operators">	

<t>

HTTP cookies <xref target="RFC6265"/> set by a pinned host can be stolen by a
network attacker who can forge web and DNS responses so as to cause a client
to send the cookies to a phony subdomain of the pinned host. To prevent this,
TKP HTTPS Servers SHOULD set the "secure" attribute and omit the "domain"
attribute on all security-sensitive cookies, such as session cookies. These
settings tell the browser that the cookie should only be presented back to the
originating host (not its subdomains), and should only be sent over HTTPS (not
HTTP) <xref target="RFC6265"/>.

</t>
</section>

<section title="For client implementers"  anchor="security_client">

<t>

A TKP pin store may contain private details of the client's connection
history. An attacker may be able to access this information by hacking or
stealing the client. Some information about the client's connection history
could also be gleaned by observing whether the client accepts or rejects
connections to phony TLS servers without correct pin descriptions. To mitigate
these risks, a TKP client SHOULD allow the user to edit or clear the pin
store.

</t>

<t>

Aside from rejecting TLS connections, clients SHOULD NOT take any actions
which would reveal to a network observer the state of the client's pin store,
as this would allow an attacker to know in advance whether a
"man-in-the-middle" attack on a particular TLS connection will succeed or be
detected.

</t>

<t>

An attacker may attempt to flood a client with spurious descriptions for
different hostnames, causing the client to delete old pins to make space for
new ones. To defend against this, clients SHOULD NOT delete active pins to
make space for new pins. Clients instead SHOULD delete inactive pins. If there
are no inactive pins to delete, then the pin store is full and there is no
space for new pins. To select an inactive pin for deletion, the client SHOULD
delete the pin with the oldest "end time".

</t>
</section>

<section title="Note on algorithm agility" anchor="future">

<t>

If the need arises for pin descriptions using different cryptographic
algorithms (e.g., if SHA256 is known to be weak), a "v2" version of TKP could
be defined, requiring assignment of a new TLS Extension number. Pin
descriptions as defined in this document would then be known as "v1" descriptions.

</t>
</section>

        </section>

	<section title="IANA considerations">
	<section title="New entry for the TLS ExtensionType Registry">
	<t>

IANA is requested to add an entry to the existing TLS ExtensionType registry,
defined in <xref target="RFC5246"/>, for "tkp"(TBD) as defined in this
document.

 </t>
</section>

</section>
<section title="Acknowledgements">
<t>

Valuable feedback has been provided by Adam Langley, Chris Palmer, Nate
Lawson, and Joseph Bonneau.

</t> </section>

    </middle>

    <back>
        <references title='Normative references'>
	
<reference
  anchor="FIPS180-2"
  target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">
  <front>
    <title>Secure Hash Standard</title>
    <author>
      <organization>National Institute of Standards and Technology</organization>
    </author>
    <date month="August" year="2002" />
  </front>
  <seriesInfo name="FIPS" value="PUB 180-2" />
</reference>

<reference 
	anchor="FIPS186-3" 
	target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">
<front>
<title>Digital Signature Standard</title>
<author>
<organization>National Institute of Standards and Technology</organization>
</author>
<date month="June" year="2009" />
</front>
<seriesInfo name="FIPS" value="PUB 186-3" />
</reference>

			<?rfc include="bib/reference.RFC.2119.xml"?>
			<?rfc include="bib/reference.RFC.3207.xml"?>
			<?rfc include="bib/reference.RFC.4648.xml"?>
			<?rfc include="bib/reference.RFC.5246.xml"?>
			<?rfc include="bib/reference.RFC.5280.xml"?>			
			<?rfc include="bib/reference.RFC.5480.xml"?>
			<?rfc include="bib/reference.RFC.5905.xml"?>
			<?rfc include="bib/reference.RFC.6066.xml"?>			
			<?rfc include="bib/reference.RFC.6090.xml"?>			
			<?rfc include="bib/reference.RFC.6265.xml"?>
	</references>
</back>

</rfc>

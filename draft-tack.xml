<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>

<rfc ipr="trust200902" docName="draft-tack.txt" category="std">

    <front>
        <title>Trust Assertions for Certificate Keys</title>
        <author initials='M.M.' surname="Marlinspike" fullname='Moxie Marlinspike'>	
            <organization/>
        </author>
        <author initials='T.P.' surname="Perrin" fullname='Trevor Perrin' 
				role="editor">
            <organization/>
			<address><email>tack@trevp.net</email></address>
        </author>
        <date/>
		<area>Security</area>
		<workgroup>TLS Working Group</workgroup>
        <abstract>
			<t>

This document defines TACK, a TLS Extension that enables a TLS server to
support "pinning" to a self-chosen signing key. A client contacting a pinned
host will require the server to present a signature from the signing key over
the TLS server's public key.

			</t>
		</abstract>
    </front>

    <middle>
		<section anchor="intro" title="Introduction">
		<section title="Overview">

			<t>

Traditionally, a TLS client verifies a TLS server's public key using a
certificate chain issued by some public CA. "Pinning" is a way for clients to
obtain increased certainty in server public keys. Clients that employ pinning
check for some constant "pinned" element of the TLS connection when
contacting a particular TLS host.

 </t>
	<t>

TACK allows clients to pin to a server-chosen signing key, known as a
"tack-signing key" or "TSK", which signs the server's TLS keys. This enables
pinning without limiting a site's flexibility to deploy different certificates
and TLS keys on different servers or at different times. Since pins can be
based on tack-signing keys instead of CA keys, trust in CAs is not required.
Additionally, a TSK may be used to revoke compromised TLS private keys, and a
pair of "overlapping" TSKs may be used to quickly introduce a new TSK if an
older one has become compromised or suspect.

	</t>

 </section> 


<section title="Requirements notation"> <t>The key words "MUST",
"MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in <xref target="RFC2119"/>.</t> 
</section>
</section>

<section title="TACK Extension">
	<section title="Definition of TackExtension">
	<t>

A new TLS ExtensionType ("tack") is defined and MAY be included by a TLS
client in the ClientHello message defined in <xref target="RFC5246"/>.

</t>
<figure><artwork>
enum {tack(TBD), (65535)} ExtensionType;
</artwork></figure>	
<t>

The "extension_data" field of this ClientHello extension SHALL be empty. A TLS
server which is not resuming a TLS session MAY respond with an extension of
type "tack" in the ServerHello. The "extension_data" field of this
ServerHello extension SHALL contain a "TackExtension", as defined below using
the TLS presentation language from <xref target="RFC5246"/>.

	</t>
<figure><artwork>
struct {
   opaque public_key[64];
   uint8  min_generation;
   uint8  generation;
   uint32 expiration;
   opaque target_hash[32];
   opaque signature[64];
} Tack;  /* 166 bytes */

struct {
   Tack tacks&lt;166...332&gt;;   /* 1 or 2 Tacks */
} TackExtension;
</artwork>
</figure>
<t>
<vspace blankLines="100" />	

</t>
</section>
<section title="Explanation of TackExtension fields">

<section title="Tack fields">
<t>
<list style="hanging">

	<t hangText="public_key:">

This field specifies the public component of the TSK which has signed this
tack. The field contains a pair of integers (x, y) representing a point on the
elliptic curve P-256 defined in <xref target="FIPS186-3"/>. Each integer is
encoded as a 32-byte octet string using the Integer-to-Octet-String algorithm
from <xref target="RFC6090"/>, and these strings are concatenated with the x
value first. (NOTE: This is equivalent to an uncompressed subjectPublicKey
from <xref target="RFC5480"/>, except that the initial 0x04 byte is omitted).

	</t>	

<t hangText="min_generation:"> 

This field publishes a min_generation for the TSK.

</t>

<t hangText="generation:"> 

This field assigns each tack a generation. Generations less than the highest
published min_generation for the TSK are considered revoked.

</t>

<t hangText="expiration:"> 

This field specifies a time after which the tack is considered expired. The
time is encoded as the number of minutes, excluding leap seconds, after
midnight UTC, January 1 1970. </t>

<t hangText="target_hash:"> 

This field is a hash of the TLS server's SubjectPublicKeyInfo <xref
target="RFC5280"/> using the SHA256 algorithm from <xref target="FIPS180-2"/>.
The SubjectPublicKeyInfo is typically conveyed as part of the server's X.509
end-entity certificate.

</t>

<t hangText="signature:">

This field is an ECDSA signature by the tack's TSK over the 8 byte ASCII
string "tack_sig" followed by the contents of the tack prior to the
"signature" field (i.e. the preceding 102 bytes). The field contains a pair of
integers (r, s) representing an ECDSA signature as defined in <xref
target="FIPS186-3"/>, using curve P-256 and SHA256. Each integer is encoded as
a 32-byte octet string using the Integer-to-Octet-String algorithm from <xref
target="RFC6090"/>, and these strings are concatenated with the r value first.

</t>
</list>
</t>
</section>

<section title="TackExtension fields">
<t>
<list style="hanging">

<t hangText="tacks:">

This field provides the server's tack(s). It SHALL contain 1 or 2 tacks. </t>

</list> </t>

</section>

</section> 
</section>

<section title="Client processing" anchor="clientproc">
<section title="Validating tacks">
<t>

Upon receiving a TackExtension, the client SHALL validate each tack by
checking that the following statements are true. If not, the client SHALL send
a fatal error alert and close the connection. The error alert SHALL be
"bad_certificate" unless otherwise specified.

<list style="numbers">
<t>If there are two tacks, they have different public keys.</t>
<t>Each tack's "generation" is >= the tack's "min_generation".</t>
<t>Each "expiration" specifies a time in the future, otherwise the client
SHALL send a fatal "certificate_expired" error alert.</t>
<t>Each "target_hash" is a correct hash of the SubjectPublicKeyInfo.</t>
<t>Each "signature" is a correct ECDSA signature.</t> 
</list>

</t> 
</section>

<section title="Handling revocation">

<t>A client MAY keep a revocation store consisting of a map associating TSKs
to min_generation values. If a tack's signing key is listed in such a store
and the tack's generation is less than the store's min_generation, the tack is
revoked. If the tack has a min_generation greater than the store's
min_generation, the store's min_generation SHOULD be updated to the tack's
value for future use.

</t>
<t>

It is undefined how the client responds to revoked tacks. However, if a client
closes a TLS connection due to a revoked tack, the client SHOULD send a fatal
"certificate_revoked" alert

</t>
</section>
<section title="Comparing pins and tacks">

<t> A client MAY wish to compare valid tacks against one or two TACK pins
which are relevant to the connection. Each pin refers to a public key or a
cryptographically-secure, second preimage-resistant hash of a public key. A
pin "matches" a tack if they reference the same public key. It is undefined
how the client receives pins. </t>

<t>


</t> <t>

If a pin has a matching, valid, nonrevoked tack, the pin and connection
"confirm" each other. Otherwise, the pin and connection "contradict" each
other. How the client responds to confirmed or contradicted connections is
left to other specifications and client policy. If a client closes a
connection due to a contradicted pin, the client SHOULD send an
"access_denied" alert.

 </t>

</section>

</section>


<section title="Advice"> 
<section title="For server operators" anchor="servadvice">
<t>
<list style="hanging">

<t hangText="Key reuse:">

All servers that are pinned to a single TSK are able to impersonate each
other, since clients will perceive their tacks as equivalent. Thus, TSKs
SHOULD NOT be reused with different hostnames unless these hostnames are
closely related. Examples where it would be safe to reuse a TSK are
hostnames aliased to the same host, hosts sharing the same TLS key, or
hostnames for a group of near-identical servers.

</t>

<t hangText="Generations:">

To revoke older generations of tacks, the server operator SHOULD first provide
all servers with a new generation of tacks, and only then provide servers with
new tacks containing the new min_generation. Otherwise, a client may receive a
min_generation update from one server but then try to contact an
older-generation server which has not yet been updated.</t>

<t hangText="Tack expiration:">

When TACK is used in conjunction with certificates it is recommended to set
the tack expiration equal to the end-entity certificate's expiration (or a
later date), allowing the tack and certificate to both be replaced at the same
time. Alternatively, short-lived tacks may be used so that a compromised TLS
private key has limited value to an attacker.</t>

</list>
</t>
</section> 
<section title="For client implementers">
<t>
<list style="hanging">
<t hangText="Clock synchronization:">

A client SHOULD take measures to prevent tacks from being erroneously rejected
as expired due to an inaccurate client clock. Such methods MAY include using
time synchronization protocols such as NTP <xref target="RFC5905"/>, or
accepting seemingly-expired tacks as "well-formed" if they expired less than T
minutes ago, where T is a "tolerance bound" set to the client's maximum
expected clock error.

</t>

</list>
</t>
</section> 
</section>

        <section title="Security considerations" anchor="security">
<section title="For server operators">	
        <t>

All servers pinned to the same TSK can impersonate each other (see <xref
target="servadvice"/>). Think carefully about this risk if using the same TSK
for multiple hostnames.

</t> <t>

Make backup copies of the TSK's private key and keep all copies in secure
locations where they can't be compromised.

</t>
<t>

A TSK's private key MUST NOT be used to perform any non-TACK cryptographic
operations. For example, using a TSK for email encryption, code-signing,
or any other purpose MUST NOT be done.

</t> <t>

HTTP cookies <xref target="RFC6265"/> set by a pinned host can be stolen by a
network attacker who can forge web and DNS responses so as to cause a client
to send the cookies to a phony subdomain of the pinned host. To prevent this,
TACK HTTPS Servers SHOULD set the "secure" attribute and omit the "domain"
attribute on all security-sensitive cookies, such as session cookies. These
settings tell the browser that the cookie should only be presented back to the
originating host (not its subdomains), and should only be sent over HTTPS (not
HTTP) <xref target="RFC6265"/>.

</t>
</section>


<section title="Note on algorithm agility" anchor="future">

<t>

If the need arises for tacks using different cryptographic algorithms (e.g.,
if SHA256 or ECDSA are shown to be weak), a "v2" version of tacks could be
defined, requiring assignment of a new TLS Extension number. Tacks as defined
in this document would then be known as "v1" tacks.

</t>
</section>

        </section>

	<section title="IANA considerations">
	<section title="New entry for the TLS ExtensionType Registry">
	<t>

IANA is requested to add an entry to the existing TLS ExtensionType registry,
defined in <xref target="RFC5246"/>, for "tack"(TBD) as defined in this
document.

 </t>
</section>

</section>
<section title="Acknowledgements">
<t>

Valuable feedback has been provided by Adam Langley, Chris Palmer, Nate
Lawson, and Joseph Bonneau.

</t> </section>

    </middle>

    <back>
        <references title='Normative references'>
	
<reference
  anchor="FIPS180-2"
  target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">
  <front>
    <title>Secure Hash Standard</title>
    <author>
      <organization>National Institute of Standards and Technology</organization>
    </author>
    <date month="August" year="2002" />
  </front>
  <seriesInfo name="FIPS" value="PUB 180-2" />
</reference>

<reference 
	anchor="FIPS186-3" 
	target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">
<front>
<title>Digital Signature Standard</title>
<author>
<organization>National Institute of Standards and Technology</organization>
</author>
<date month="June" year="2009" />
</front>
<seriesInfo name="FIPS" value="PUB 186-3" />
</reference>

			<?rfc include="bib/reference.RFC.2119.xml"?>
			<?rfc include="bib/reference.RFC.5246.xml"?>
			<?rfc include="bib/reference.RFC.5280.xml"?>			
			<?rfc include="bib/reference.RFC.5480.xml"?>
			<?rfc include="bib/reference.RFC.5905.xml"?>
			<?rfc include="bib/reference.RFC.6090.xml"?>			
			<?rfc include="bib/reference.RFC.6265.xml"?>
	</references>
</back>

</rfc>
